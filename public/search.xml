<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决JPEG图片显示方向不正确的问题]]></title>
    <url>%2F2019%2F11%2F17%2Fd3c4828a43569ce3ca593dc66b1eb668%2F</url>
    <content type="text"><![CDATA[背景： 一些jpeg图片，在pc中用图片查看器打开是正的，但是放到浏览器中，就横着了；有一个上传人脸的需求，用手机拍完人脸照片，在应用中显示所拍的照片总是横着的。今天，我们就来解决这个问题。为什么JEPG图片会横着显示？首先，我们看一个github上的一个关于此问题的issue：https://github.com/GoogleChromeLabs/squoosh/issues/299这个问题讨论的是chrome显示jpeg图片，旋转了90度的问题。为什么会旋转呢？因为JEPG图片的EXIF data中有一个控制旋转的属性Orientation，但是有一些应用程序显示图片的时候会忽略这个属性，就导致图片在一些应用程序中显示出来和原本的方向不一致。 这里有一张JEPG图片的EXIF数据（可以看到第一个属性就是 Orientation）： 让图片永远都正着显示因为 JPEG的 Orientation 属性被忽略了，那么当检测到图片Orientation的值表示需要旋转的时候，我们就主动将JPEEG图片旋转，并且改正或者去掉新图片的Orientation 字段。 // 使用exif-js 这个库去获取jpeg图片的EXIF元数据 (https://github.com/exif-js/exif-js)// 旋转图片的工具,(旋转之后的图片的EXIF data被移除) import * as EXIF from 'exif-js' // npm install exif-js // &lt;img id="show-image" /&gt;,用来显示旋转后的图像 var image = document.getElementById('show-image') // &lt;input id="image-input" type="file" name="imag" /&gt; var imageInput = document.getElementById('image-input') imageInput.onchange = function (evt) &#123; console.log("onchange: ...") let file = evt.target.files[0] rotateImage(file).then(data =&gt; &#123; image.src = data.base64 &#125;) &#125; function fileToBinary (file) &#123; // 读取图片数据 return new Promise(function (resolve, reject) &#123; var reader = new FileReader() reader.onload = function(evt) &#123; if (this.result instanceof ArrayBuffer) &#123; // resolve(new Uint8Array(reader.result)) resolve(this.result) &#125; &#125; reader.readAsArrayBuffer(file) &#125;) &#125; // 将Blob 对象以fileName文件名下载下来 function downloadBlob (blob, fileName) &#123; const url = window.URL.createObjectURL(blob) const link = document.createElement('a') link.href = url link.setAttribute('download', fileName) document.body.appendChild(link) link.click() document.body.removeChild(link) // 下载完成移除元素 window.URL.revokeObjectURL(url) // 释放掉blob对象 &#125; function rotateImage(file)&#123; return new Promise((resolve, reject) =&gt; &#123; fileToBinary(file).then((binaryFile) =&gt; &#123; let meta = EXIF.readFromBinaryFile(binaryFile) let orientation = meta.Orientation let formData = new FormData() let rotationMap = &#123; 3: 180, 6: 90, 8: 270 &#125; // 不需要旋转 if (meta === false || !rotationMap[orientation]) &#123; formData.append('file', file, 'face.jpeg') return resolve(&#123; base64: '', formData: formData, rotated: false &#125;) &#125; let rotationDegree = 0 let targetWidth = 200 rotationDegree = rotationMap[orientation] || 0 let image = document.createElement('img') image.onload = function () &#123; var canvas = document.createElement('canvas') let ctx = canvas.getContext('2d') let rate = Math.min(targetWidth / image.width, 1) let imageWidth = image.width * rate let imageHeight = image.height * rate if (rotationDegree === 90 || rotationDegree === 270) &#123; canvas.width = imageHeight canvas.height = imageWidth &#125; else &#123; canvas.width = image.width canvas.height = image.height &#125; ctx.fillStyle = 'rgba(255, 255, 255, 0)' ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.save() ctx.fillRect(0, 0, canvas.width, canvas.height) ctx.translate(canvas.width / 2, canvas.height / 2) ctx.rotate(rotationDegree * Math.PI / 180) if (rotationDegree === 90 || rotationDegree === 270) &#123; ctx.drawImage(image, -canvas.height / 2, -canvas.width / 2 + (canvas.width - imageHeight) / 2, imageWidth, imageHeight) &#125; else &#123; ctx.drawImage(image, -canvas.width / 2, -canvas.height / 2, imageWidth, imageHeight) &#125; ctx.restore() canvas.toBlob((blob) =&gt; &#123; formData.append('file', blob, 'face.jpeg') let base64 = canvas.toDataURL('image/jpeg', 0.8) console.log('rotated image blob: ', blob) // downloadBlob(blob, '123.jpg') // 下载图片 resolve(&#123; base64: base64, rotated: true, formData: formData &#125;) &#125;, 'image/jpeg', 0.8) &#125; image.src = URL.createObjectURL(file) &#125;) &#125;) &#125; 例子效果：]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jpg</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用操作]]></title>
    <url>%2F2019%2F11%2F13%2Fa43fd1c509d10e4d08fc1f789d58cb23%2F</url>
    <content type="text"><![CDATA[漂亮打印git loggit log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative添加修改或者新文件到待commit队列### add 的文件是支持正则匹配的git add &lt;file(s)&gt;### add all changes to commiter queuegit add .### 查看某个commit的修改内容git show &lt;commit-id&gt;git diff &lt;commit-id&gt;^!##### e.g. git show d34ff657f5 git diff d34ff657f5^!``` ### 提交已添加的文件到本地仓库并创建一个新的版本```shgit commit -m "commit message"### also can combine git add &amp; git commit in one commandgit commit -m "commit message" -a 推送到远程仓库### origin 是仓库名（默认就是origin），branch_name 是分支名git push origin &lt;branch-name&gt; 仓库创建一个仓库### from existed repo git clone &lt;repo-url&gt;### create a new local repogit init [&lt;local-directory&gt;] 分支查看分支### 查看本地分支git branch### 查看本地和远端的分支git branch -va### 查看本地分支和远程分支的对应关系git remote show &lt;repo-name&gt; ## git remote show origin 创建分支### 仅仅创建一个新分支在本地git checkout &lt;new-branch-name&gt;### 创建一个分支，并且将工作区切换到新创建的分支git checkout -b &lt;new-branch-name&gt;### 拉取远程分支到本地，并切换分支git checkout -b &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt;#### e.g.: git checkout -b test origin/test### 把远程分支拉取到本地，不切换分支 (--tranck 选项现在是默认的了)git branch &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt; [--track]#### e.g.: git branch test origin/test 将本地分支推送到远程仓库## 远程分支不存在的情况### remote-name: 通常是 origin； local-branch-name: 本地分支名； remote-branch-name: 要创建的远程分支名 git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt; ## 远程分支存在的情况（但是没有关联） ### 首先关联本地分支和远程分支 git push -u &lt;remote-name&gt; &lt;branch-name&gt; #### or git branch --set-upstream-to=&lt;remote-name&gt;/&lt;remote-branch&gt; &lt;local-branch&gt; 更新分支### 跟新本地分支git pull### 更新远程分支信息git remote update### 使用远程的代码强制更新本地的代码 （强制本地代码和线上的一致）v1.0git checkout .git pull### 使用远程的分支代码强制更新本地的代码（强制本地代码和线上的一致）v2.0git fetch --allgit reset --hard origin/mastergit pull Tag创建taggit tag -a &lt;tag-name&gt; -m &lt;tag-message&gt; 删除tag### 删除本地taggit tag -d &lt;tag-name&gt;### 删除远端taggit push --delete &lt;repo-name&gt; &lt;tag-name&gt;or git push &lt;repo-name&gt; :refs/tags/&lt;tag-name&gt;### e.g.: git push --delete origin tag-r0### e.g.: git push origin :refs/tags/tag-r0 查看tag### 查看所有的taggit tag### 查看单个taggit tag -l &lt;tag-name&gt;### 查看一个tag的具体信息git show &lt;tag-name&gt; 推送tag到远程## push single taggit push &lt;remote-name&gt; &lt;tag-name&gt;## push all tags (not recommended)git push --tags 撤销工作目录所有的更改（包括新创建的文件）git reset --hard # removes staged and working directory changes## !! be very careful with these !!## you may end up deleting what you don't want to## read comments and manual.git clean -f -d # remove untrackedgit clean -f -x -d # CAUTION: as above but removes ignored files like config.git clean -fxd :/ # CAUTION: as above, but cleans untracked and ignored files through the entire repo (without :/, the operation affects only the current directory) git仓库存储账号密码，不用每次都输入账号密码（针对https协议的仓库地址）$ git config credential.helper store$ git push https://github.com/owner/repo.gitUsername for 'https://github.com': &lt;USERNAME&gt;Password for 'https://USERNAME@github.com': &lt;PASSWORD&gt;## 执行完上面的命令之后，以后所有的push都不再需要提交代码## 如果想让此功能有个时间限制，可以这样git config --global credential.helper 'cache --timeout 7200'## 7200秒后失效，push需要重新输入账号密码]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
