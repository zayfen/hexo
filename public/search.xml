<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[布隆过滤（Bloom Filter）]]></title>
    <url>%2F2019%2F11%2F18%2Fbbc765cf2f120d4208792bc259324906%2F</url>
    <content type="text"><![CDATA[Bloom Filter1. 什么是布隆过滤？布隆过滤是应用于大数据中检测一个数据是否在一个集合中的搜索过滤算法。2. 应用场景比如如何在成千上万的网址中快速地识别出恶意的网址，在成千上万的邮件中快速识别出恶意的邮件等3. 算法简单描述布隆过滤是在一个bitmap中预先通过k个hash函数插入一些目标数据标记，表示为下图：假设这里的bitmap(所有的位都初始化为0)是有10个bits，有3个hash 函数，有一个目标数据“cat”，那么将cat映射标记到bitmap就是通过3个hash函数分别计算cat的hash值，将hash值转换成bitmap的索引，并将对应索引位置的bit置为1，至此，我们就标记了一个目标数据，目前cat就是我们要过滤的数据，当在很多的数据中要识别出“cat”的时候，就可以通过建立好的这个bitmap来识别了。 比如，现在有3个数据来了，分别是 “dog”，“cat”，“pig”，我们需要从中识别出“cat”，怎么样识别呢？“dog” =&gt; 映射到 bitmap[1], bitmap[2], bitmap[3], 发现都不是1，则‘dog‘就不是目标数据“cat” =&gt; 映射到 bitmap[1], bitmap[3], bitmap[7],发现所有的都是1， 则 ‘cat’就是目标数据“pig” =&gt; 映射到 bitmap[8], bitmap[9], bitmap[10]，发现都不是1， 则‘pig’就不是目标数据这样通过重新计算hash来和bitmap中的对比就能过滤掉一些目标数据了但是这里其实还有一个问题，存在一个不同的目标,比如“bird”，这个通过hash函数计算出来的结果可能在bitmap中都为1, 这种情况是无法避免的，我们称之为“误判”，这种识别错误的概率和目标数据，bitmap大小和hash函数的数据是相关联的 4. 算法推导布隆过滤的原理大概了解了，但是这里有个问题是，如何确定bitmap的大小以及hash function的多少，我们可以通过指定一个错误概率的大小和初始的目标数据来确定 bitmap的大小和hash function 的数量 假设有 K个hash函数，M bits的bitmap， N个初始数据, 对于bitmap中的一个特定点，K个hash函数映射到此点的·概率相等，即一个点被函数命中的概率为： p_1=\frac{1}{M}则一个点不被命中的概率为： p_2=1-\frac{1}{M}则K个函数都不命中的概率为： p_3=\left(1-\frac{1}{M}\right)^K假设已经存在了N个数据，那么一个特定的点在N个数据下都没有被命中的概率为： p_4=\left(1-\frac{1}{M}\right)^{KN}那么这个点命中的概率为： p_5=1-\left(1-\frac{1}{M}\right)^{KN}现在来判断一个不再初始数据集合中的数据被命中的概率，即，满足K个hash函数计算的结果都被命中，这种情况的概率为： p_6=\left(1-\left(1-\frac{1}{M}\right)^{KN}\right)^K因为目标数据命中的概率为1，所以当p_6越小的时候，也就表示别的数据被命中的概率越低。根据 1-\frac{1}{m}\approx\ell^{-\frac{1}{m}}可以将p_6简化为：\ell^{-\frac{KN}{M}} p_6\approx\left(1-\ell^{-\frac{KN}{M}}\right)^K因为K为正数，取其值为\frac{M}{N}\ln2， 则 p_6\approx\left(1-\ell^{-\frac{\left(\frac{M}{N}\ln2\right)N}{M}}\right)^{\frac{M}{N}\ln2}\ln{p_6}\approx{\frac{M}{N}\ln2}\times\ln\left(1-\ell^{-\frac{\left(\frac{M}{N}\ln2\right)N}{M}}\right)\ln{p_6}\approx{\frac{M}{N}\ln2}\times\ln\left(1-\ell^{-\ln2}\right)\ln{p_6}\approx{\frac{M}{N}\ln2}\times\ln\left(1-\frac{1}{\ell^{\ln2}}\right)\ln{p_6}\approx\frac{M}{N}\ln2\times\ln\frac{1}{2}\ln{p_6}\approx\frac{M}{N}\ln2\times{\left(-\ln2\right)}\ln{p_6}\approx{-\frac{M}{N}{\left(\ln2\right)}^2}所以最终 M = -\frac{\ln{p_6} \times N}{ \left(\ln2\right)^2 }所以当我们希望命中的概率是 0.001, 初始化插入了 10000 条数据， 那么M 就等于 Math.log(0.001)*10000 / Math.pow(Math.log(2), 2) * -1 // output: 143775.87566051158 那么 K就等于 143776 / 10000 * Math.log(2) // output: 9.965... 也就是需要10个hash函数 5. 代码实现https://github.com/zhangyunfeng/BloomFilter/tree/master/src]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>bloom filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见WEB安全防御]]></title>
    <url>%2F2019%2F11%2F18%2Ff97ef80c3fff95b1c02a4a937d666b66%2F</url>
    <content type="text"><![CDATA[WEB安全[TOC]一、漏洞分类 XSS漏洞 CSRF漏洞 SSRF漏洞 SQL漏洞 二、各种漏洞介绍XSS漏洞 什么是XSS漏洞XSS漏洞全称跨站脚本攻击，英文全称 Cross-site Scripting, 为了不和css名字重复，所以取名XSS. XSS漏洞主要是能够利用代码的漏洞，通过一些技巧在浏览器端执行非法的javascript脚本，这些非法的javascript脚本拥有当前登录用户的权限，可以执行一些非法操作，从而给用户或者企业带来损失。 XSS漏洞的种类 DOM型XSS 这个是最常见的一个XSS漏洞了，在在浏览器端操作DOM时产生。比如，在一个input中输入一个字符串，并将字符串显示在页面中，如果没有对字符串做校验就可能会产生DOM型xss漏洞。例子： https://pastebin.com/C1inFY9n https://pastebin.com/C1inFY9n 反射型XSS 反射型XSS是发送到服务端的数据没有做参数的校验和过滤，只是简单地把用户输入的数据”反射”给浏览器,导致在浏览器中渲染处理参数时引入了js脚本。反射型XSS也叫做”非持久型XSS” (Non-persistent XSS) 存储型XSS . 存储型XSS会把用户输入的数据”存储”在服务端, 这种XSS具有很强的稳定性.最常见的一种情况就是,在博客中写一段包含有恶意javascript代码发表, 这段恶意的代码就会随着博客内容存储到数据库中,如何人访问这篇博客都会受到攻击 XSS漏洞的危害a. 窃取cookie,登录别人账户攻击者可以构造一个链接,当被攻击者点击了这个链接之后,会触发xss漏洞,就会执行一个js脚本,该js脚本会携带cookie信息通过img标签或者script标签等可以跨域访问的标签将信息发送给攻击者.b. 构造GET和POST请求,删除或者篡改受害者信息比如有个删除文章的接口: http://blog.abc.com/delete?id=post_idxxx, 当攻击者知道被攻击者的一篇文章的id的时候,就可以通过xss payload来请求删除文章的接口, 修改被攻击者信息同理.c. XSS钓鱼xss的攻击过程都是需要在浏览器中通过javascript自动执行的.如果在攻击的过程中存在和用户交互的情况就比较麻烦了,比如需要输入旧密码或者输入图片上的验证码,虽然比较麻烦,但是我们还是可以实施xss攻击的,比如把显示验证码的图片地址发送给攻击者,或者制作一个长得一模一样的输入帐号密码的界面欺骗被攻击者.这些攻击方法就是xss钓鱼.d. 识别用户的浏览器,利用浏览器的漏洞对系统进行攻击浏览器有漏洞,虽然浏览器会通过更新来解决这些漏洞,但是不能保证所有的人都更新到最新版本,当检测到有漏洞的浏览器版本,就可以通过浏览器漏洞对系统进行攻击.e. 识别用户安装的软件执行挂马攻击在IE中可以通过判断 ActieX空间的classid是否存在来判断用户是否安装了软件.黑客通过判断被攻击者安装的软件,选择对应的浏览器漏洞,最终达到植入木马的目的.比如在IE中通过如下的代码就可以判断用户是否安装了迅雷:try &#123; var obj = new ActiveXObject('XunLeiBHO.ThunderIEHelper');&#125; catch (error) &#123; // 异常, 没有安装此软件&#125;if (obj) &#123; // 安装了迅雷&#125; 另外,可以通过flash的一个 system.capabilities对象来找出电脑的硬件信息,还可以通过判断特定的DOM来判断浏览器安装了哪些插件. 通过xss攻击还可以知道被攻击者访问了哪些页面(通过 :visited 伪元素判断), 还可以在jre环境中通过调用Java Applete的接口获取客户端的本地ip地址. XSS的防御a. HttpOnly通过在cookie中设置HttpOnly这个属性,可以阻止javascript访问cookie内容.b. 输入检查对输入的值进行字符类型,字符长度检查,比如手机号码,不能出现字母,而且长度为11, 对一些特殊字符,比如尖括号进行转义编码,或者一些特殊的字符串进行过滤,比如 &lt;script&gt;, javascript:.c. 输出检查执行安全的编码函数, htmlEncode, javascriptEncode.在html中输出变量$var,使用 htmlEncode对$var进行编码.在html中的onclick等事件中输出,使用javascript对$var编码在javascript中输出$var, 使用 javascript对$var编码在css中,禁止变量输出,即不要在style中使用$var变量在地址中输出,使用urlEncoded. 处理富文本通过htmlparser解析文本,过滤掉危险标签 &lt;iframe&gt;, &lt;script&gt;, &lt;base&gt;, &lt;form&gt;等, 在富文本中可选择的标签使用白名单,避免使用黑名单,即指定富文本中只能使用哪几种标签.e.编写代码时,注意这些地方;document.write();document.writeln();xxx.innerHTML();xxx.outerHTML();innerHTML.replace();document.attachEvent();window.attachEvent();document.location.replace();document.location.assign();// 页面中所有的input输入框window.location(href, hash, ...)window.namedocument.referrerdocument.cookielocalstorageXMLHttpRequest // 主要是返回的数据 CSRF漏洞CSRF漏洞,全称Cross Site Request Forgery/ˈfɔːdʒəri/ 伪造, 比如存在一个转账的接口:http://bank.com/transform/?money=xxx&amp;to=zzz; 攻击者可以伪造一个链接 http://bank.com/transform/?money=1&amp;o=lisi, 诱惑用户点击这个链接,那么用户在神不知鬼不觉之下就转移了1元钱给李四, 这个伪造的链接可以放到一个网页的img标签中, 当用户点击这个网页的时候,钱就被神不知鬼不觉的转走了. 为什么伪造的请求会请求通过呢?因为用户的浏览器成功的发送了Cookie给服务器. 防御方法: 增加一个随机的token, 每次转账的时候都要带上这个随机额token, 同事后台需要校验token的正确性,比如 http://bank.com/transform/?money=xxx&amp;to=zzz&amp;token=abcUx23Flzd, 这样攻击者不知道token的情况下,构造的链接就会无效. 点击劫持(ClickJacking)点击劫持是一种视觉上的欺骗手段.攻击者使用一个透明的iframe,覆盖在一个网页上,然后诱使用户在网页上进行操作,通过调整iframe的位置,当用户点击一个按钮的时候,其实是点击在iframe上的一个功能按钮上. 点击劫持有: Flash点击劫持 图片覆盖攻击 拖拽劫持与数据窃取 触屏劫持 防御:禁止跨域的iframe来防御, 使用HTTP头 X-Frame-Options, X-Frame-Options有3个选项, DENY, SAMEORIGIN, ALLOW-FROM origin]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索算法]]></title>
    <url>%2F2019%2F11%2F18%2Fb7d273159f6becc31fc5174ea7582c5e%2F</url>
    <content type="text"><![CDATA[线性搜索线性搜索也是最简单的搜索算法，简单来说，就是对一个数组或者顺序容器，进行从头到尾的遍历，一个一个的找到目标元素// 简单的线性搜索算法实现template &lt;typename T&gt;int linear_search(const std::vector&lt;T&gt;&amp; vec, const T&amp; x)&#123; int index = -1; for(const auto&amp; element : vec) &#123; index++; if(element == x) &#123; return index; &#125; &#125; return -1;&#125; 时间复杂度： O(N) 二分查找（Binary Search）二分查找，是给定一个有序的数组或者顺序容器，每次取容器的中间位置的元素和目标元素对比来缩短查找的范围。过程可以简单描述如下：// 二分查找template&lt;typename T&gt;extern int binary_search(const std::vector&lt;T&gt;&amp; vec, const int low, const int high, const T&amp; x) &#123; std::cout &lt;&lt; "binary_search low " &lt;&lt; low &lt;&lt; " high " &lt;&lt; high &lt;&lt; std::endl; if (low &gt; high) &#123; // 没有找到 return -1; &#125; int middle = low + (high - low) / 2; // 搜索区间缩短一半 if (x == vec.at(middle)) &#123; return middle; &#125; int low_ = vec.at(middle) &gt; x ? low : middle + 1; int high_ = vec.at(middle) &gt; x ? middle - 1 : high; return binary_search(vec, low_, high_, x);&#125; 时间复杂度： O(LogN) 跳跃查找（Jump Search）给定一个有序的顺序容器，容器宗有n个元素， 将元素分成m份，每份 n/m 个元素。然后我们按照每n/m个元素间隔去查找元素，找到要搜索的元素所在的区间[i, i+n/m), 然后在这个区间中判断值 template&lt;typename T&gt;extern int jump_search(const std::vector&lt;T&gt;&amp; vec, const T&amp; x) &#123; if (vec.size() == 0) &#123; return -1; &#125; int stepWidth = std::sqrt(vec.size()); int prevStepIndex = 0; int stepIndex = std::min(stepWidth, int(vec.size())) - 1; while (vec.at(stepIndex) &lt; x) &#123; prevStepIndex = stepIndex; stepIndex = std::min(stepWidth + stepIndex, int(vec.size() - 1)); if (prevStepIndex == stepIndex) &#123; // 到达尾部，没有找到x元素 return -1; &#125; &#125; // ignore all elements less than x while (vec.at(prevStepIndex) &lt; x) &#123; prevStepIndex++; if (prevStepIndex &gt;= vec.size()) &#123; return -1; &#125; &#125; // if element found if (vec.at(prevStepIndex) == x) &#123; return prevStepIndex; &#125; return -1;&#125; 算法分析寻找要查找的元素所在的区间，最大需要为 m - 1次比较，再区间段中最大需要n/m次比较 ，所以时间复杂度是 O((m-1) + n/m),要使 (m-1) + n/m 最小，需要 m = sqrt(n),所有， 时间复杂度是 O(sqrt(n) - 1 + n/sqrt(n)) 也就是 O(sqrt(n)) 让 n/m+m-1 = 0, jump search 的时间复杂度，是介于线性查找和二分查找之间的，所以jump search 的性能没有比二分查找要好，但是jump search 有一个好处，就是他只需要回退一次，加入我们要查找一个最小的元素，jump search 只需要查找一个，而二分查找需要查满，这种情况下，jump search 是优于 二分查找的。 差值搜索 （Interpolation Search）差值搜索是对二分搜索的优化，二分搜索永远都是从搜索区间的中间位置开始切分，而差值搜索会从选择从要搜索的元素最接近的位置开始切分，这样就有利于尽快的找到要搜索的元素 template&lt;typename T&gt;inline int position(const std::vector&lt;T&gt;&amp; vec, const T&amp; x, int low, int high) &#123; return low + (high - low) * ((x - vec.at(low)) / (vec.at(high) - vec.at(low)));&#125;template &lt;typename T&gt;int interpolation_search(const std::vector&lt;T&gt;&amp; vec, const T&amp; x) &#123; int low = 0; int high = vec.size() - 1; while (low &lt;= high &amp;&amp; x &gt;= vec.at(low) &amp;&amp; x &lt;= vec.at(high)) &#123; int pos = position(vec, x, low, high); printf("position is %d \n", pos); if (vec.at(pos) == x) &#123; return pos; &#125; if (vec.at(pos) &lt; x) &#123; low = pos + 1; continue; &#125; high = pos - 1; &#125; return -1;&#125; 算法分析：如果顺序容器中的元素是均匀分布的，那么就是时间复杂度就是 O(log log n)), 最坏的情况是 O(n)]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome调试微信web页面]]></title>
    <url>%2F2019%2F11%2F17%2F302d853864089ff3288321c00a69a043%2F</url>
    <content type="text"><![CDATA[如何用Chrome调试微信web页面 微信调试有官方的微信开发者工具，这个工具很方便，但是有一个不方便就是调试公众号页面的时候，需要公众号给你授予开发者权限，但是有的时候，你仅仅只是想调试页面的样式和一些dom结构，这个时候直接用chrome调试微信web页面就显得特别方便了。 步骤（此处仅仅在android手机上做了测试）1. 打开android手机的开发者模式 和 usb调试 每个手机打开方式都不一样，请自行搜索解决方案 2. 打开chrome的 Remote Devices 3. 手机连接电脑 手机连接电脑的时候，会弹出一个usb授权提示弹窗，点解确定 4. 在Chrome上的 Remote Devices上查看链接的手机情况 5. 调试手机上的页面 点击要调试的页面的右边的 Inspect按钮，就可以打开进行调试了。 但是这个时候我们发现仅仅只能看到浏览器的页面，没有看到微信的web页面 6. 手机微信打开 http://debugx5.qq.com, 并勾选 打开TBS内核Inspector调试功能 勾选后会提示重启，点击确定就行 7. 微信上打开要调试的web 页面，就可以在chrome中看到了 8. 点击chrome中 inspect按钮及可以开始调试了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>debugger</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决JPEG图片显示方向不正确的问题]]></title>
    <url>%2F2019%2F11%2F17%2Fd3c4828a43569ce3ca593dc66b1eb668%2F</url>
    <content type="text"><![CDATA[背景： 一些jpeg图片，在pc中用图片查看器打开是正的，但是放到浏览器中，就横着了；有一个上传人脸的需求，用手机拍完人脸照片，在应用中显示所拍的照片总是横着的。今天，我们就来解决这个问题。为什么JEPG图片会横着显示？首先，我们看一个github上的一个关于此问题的issue：https://github.com/GoogleChromeLabs/squoosh/issues/299这个问题讨论的是chrome显示jpeg图片，旋转了90度的问题。为什么会旋转呢？因为JEPG图片的EXIF data中有一个控制旋转的属性Orientation，但是有一些应用程序显示图片的时候会忽略这个属性，就导致图片在一些应用程序中显示出来和原本的方向不一致。 这里有一张JEPG图片的EXIF数据（可以看到第一个属性就是 Orientation）： 让图片永远都正着显示因为 JPEG的 Orientation 属性被忽略了，那么当检测到图片Orientation的值表示需要旋转的时候，我们就主动将JPEEG图片旋转，并且改正或者去掉新图片的Orientation 字段。 // 使用exif-js 这个库去获取jpeg图片的EXIF元数据 (https://github.com/exif-js/exif-js)// 旋转图片的工具,(旋转之后的图片的EXIF data被移除) import * as EXIF from 'exif-js' // npm install exif-js // &lt;img id="show-image" /&gt;,用来显示旋转后的图像 var image = document.getElementById('show-image') // &lt;input id="image-input" type="file" name="imag" /&gt; var imageInput = document.getElementById('image-input') imageInput.onchange = function (evt) &#123; console.log("onchange: ...") let file = evt.target.files[0] rotateImage(file).then(data =&gt; &#123; image.src = data.base64 &#125;) &#125; function fileToBinary (file) &#123; // 读取图片数据 return new Promise(function (resolve, reject) &#123; var reader = new FileReader() reader.onload = function(evt) &#123; if (this.result instanceof ArrayBuffer) &#123; // resolve(new Uint8Array(reader.result)) resolve(this.result) &#125; &#125; reader.readAsArrayBuffer(file) &#125;) &#125; // 将Blob 对象以fileName文件名下载下来 function downloadBlob (blob, fileName) &#123; const url = window.URL.createObjectURL(blob) const link = document.createElement('a') link.href = url link.setAttribute('download', fileName) document.body.appendChild(link) link.click() document.body.removeChild(link) // 下载完成移除元素 window.URL.revokeObjectURL(url) // 释放掉blob对象 &#125; function rotateImage(file)&#123; return new Promise((resolve, reject) =&gt; &#123; fileToBinary(file).then((binaryFile) =&gt; &#123; let meta = EXIF.readFromBinaryFile(binaryFile) let orientation = meta.Orientation let formData = new FormData() let rotationMap = &#123; 3: 180, 6: 90, 8: 270 &#125; // 不需要旋转 if (meta === false || !rotationMap[orientation]) &#123; formData.append('file', file, 'face.jpeg') return resolve(&#123; base64: '', formData: formData, rotated: false &#125;) &#125; let rotationDegree = 0 let targetWidth = 200 rotationDegree = rotationMap[orientation] || 0 let image = document.createElement('img') image.onload = function () &#123; var canvas = document.createElement('canvas') let ctx = canvas.getContext('2d') let rate = Math.min(targetWidth / image.width, 1) let imageWidth = image.width * rate let imageHeight = image.height * rate if (rotationDegree === 90 || rotationDegree === 270) &#123; canvas.width = imageHeight canvas.height = imageWidth &#125; else &#123; canvas.width = image.width canvas.height = image.height &#125; ctx.fillStyle = 'rgba(255, 255, 255, 0)' ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.save() ctx.fillRect(0, 0, canvas.width, canvas.height) ctx.translate(canvas.width / 2, canvas.height / 2) ctx.rotate(rotationDegree * Math.PI / 180) if (rotationDegree === 90 || rotationDegree === 270) &#123; ctx.drawImage(image, -canvas.height / 2, -canvas.width / 2 + (canvas.width - imageHeight) / 2, imageWidth, imageHeight) &#125; else &#123; ctx.drawImage(image, -canvas.width / 2, -canvas.height / 2, imageWidth, imageHeight) &#125; ctx.restore() canvas.toBlob((blob) =&gt; &#123; formData.append('file', blob, 'face.jpeg') let base64 = canvas.toDataURL('image/jpeg', 0.8) console.log('rotated image blob: ', blob) // downloadBlob(blob, '123.jpg') // 下载图片 resolve(&#123; base64: base64, rotated: true, formData: formData &#125;) &#125;, 'image/jpeg', 0.8) &#125; image.src = URL.createObjectURL(file) &#125;) &#125;) &#125; 例子效果：]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jpg</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用操作]]></title>
    <url>%2F2019%2F11%2F13%2Fa43fd1c509d10e4d08fc1f789d58cb23%2F</url>
    <content type="text"><![CDATA[漂亮打印git loggit log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative添加修改或者新文件到待commit队列### add 的文件是支持正则匹配的git add &lt;file(s)&gt;### add all changes to commiter queuegit add .### 查看某个commit的修改内容git show &lt;commit-id&gt;git diff &lt;commit-id&gt;^!##### e.g. git show d34ff657f5 git diff d34ff657f5^!``` ### 提交已添加的文件到本地仓库并创建一个新的版本```shgit commit -m "commit message"### also can combine git add &amp; git commit in one commandgit commit -m "commit message" -a 推送到远程仓库### origin 是仓库名（默认就是origin），branch_name 是分支名git push origin &lt;branch-name&gt; 仓库创建一个仓库### from existed repo git clone &lt;repo-url&gt;### create a new local repogit init [&lt;local-directory&gt;] 分支查看分支### 查看本地分支git branch### 查看本地和远端的分支git branch -va### 查看本地分支和远程分支的对应关系git remote show &lt;repo-name&gt; ## git remote show origin 创建分支### 仅仅创建一个新分支在本地git checkout &lt;new-branch-name&gt;### 创建一个分支，并且将工作区切换到新创建的分支git checkout -b &lt;new-branch-name&gt;### 拉取远程分支到本地，并切换分支git checkout -b &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt;#### e.g.: git checkout -b test origin/test### 把远程分支拉取到本地，不切换分支 (--tranck 选项现在是默认的了)git branch &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt; [--track]#### e.g.: git branch test origin/test 将本地分支推送到远程仓库## 远程分支不存在的情况### remote-name: 通常是 origin； local-branch-name: 本地分支名； remote-branch-name: 要创建的远程分支名 git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt; ## 远程分支存在的情况（但是没有关联） ### 首先关联本地分支和远程分支 git push -u &lt;remote-name&gt; &lt;branch-name&gt; #### or git branch --set-upstream-to=&lt;remote-name&gt;/&lt;remote-branch&gt; &lt;local-branch&gt; 更新分支### 跟新本地分支git pull### 更新远程分支信息git remote update### 使用远程的代码强制更新本地的代码 （强制本地代码和线上的一致）v1.0git checkout .git pull### 使用远程的分支代码强制更新本地的代码（强制本地代码和线上的一致）v2.0git fetch --allgit reset --hard origin/mastergit pull Tag创建taggit tag -a &lt;tag-name&gt; -m &lt;tag-message&gt; 删除tag### 删除本地taggit tag -d &lt;tag-name&gt;### 删除远端taggit push --delete &lt;repo-name&gt; &lt;tag-name&gt;or git push &lt;repo-name&gt; :refs/tags/&lt;tag-name&gt;### e.g.: git push --delete origin tag-r0### e.g.: git push origin :refs/tags/tag-r0 查看tag### 查看所有的taggit tag### 查看单个taggit tag -l &lt;tag-name&gt;### 查看一个tag的具体信息git show &lt;tag-name&gt; 推送tag到远程## push single taggit push &lt;remote-name&gt; &lt;tag-name&gt;## push all tags (not recommended)git push --tags 撤销工作目录所有的更改（包括新创建的文件）git reset --hard # removes staged and working directory changes## !! be very careful with these !!## you may end up deleting what you don't want to## read comments and manual.git clean -f -d # remove untrackedgit clean -f -x -d # CAUTION: as above but removes ignored files like config.git clean -fxd :/ # CAUTION: as above, but cleans untracked and ignored files through the entire repo (without :/, the operation affects only the current directory) git仓库存储账号密码，不用每次都输入账号密码（针对https协议的仓库地址）$ git config credential.helper store$ git push https://github.com/owner/repo.gitUsername for 'https://github.com': &lt;USERNAME&gt;Password for 'https://USERNAME@github.com': &lt;PASSWORD&gt;## 执行完上面的命令之后，以后所有的push都不再需要提交代码## 如果想让此功能有个时间限制，可以这样git config --global credential.helper 'cache --timeout 7200'## 7200秒后失效，push需要重新输入账号密码]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
