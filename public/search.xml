<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单介绍 line-box、vertical-line、line-height 和 font]]></title>
    <url>%2F2019%2F12%2F10%2F20197a10d04b8a4be9e5ef48897dee9c%2F</url>
    <content type="text"><![CDATA[vertical-align, line-height, and fontBox dimensionsFont 描述在css中， 将 baseline 到 ascender line 的距离设为A，将baseline 到 descender line的距离设为D，AD = A + D, 也就是ascender line 到 descender line 的距离。Inline-level elements and inline boxes from https://www.w3.org/TR/CSS21/visuren.html#inline-level Inline-level elements are those elements of the source document that do not form new blocks of content; the content is distributed in lines (e.g., emphasized pieces of text within a paragraph, inline images, etc.). The following values of the ‘display’ property make an element inline-level: ‘inline’, ‘inline-table’, and ‘inline-block’. Inline-level elements generate inline-level boxes, which are boxes that participate in an inline formatting context. An inline box is one that is both inline-level and whose contents participate in its containing inline formatting context. A non-replaced element with a ‘display’ value of ‘inline’ generates an inline box. Inline-level boxes that are not inline boxes (such as replaced inline-level elements, inline-block elements, and inline-table elements) are called atomic inline-level boxes because they participate in their inline formatting context as a single opaque box. Block-level elements and block boxesfrom https://www.w3.org/TR/CSS21/visuren.html#block-level Block-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the ‘display’ property make an element block-level: ‘block’, ‘list-item’, and ‘table’. Block-level boxes are boxes that participate in a block formatting context. Each block-level element generates a principal block-level box that contains descendant boxes and generated content and is also the box involved in any positioning scheme. Some block-level elements may generate additional boxes in addition to the principal box: ‘list-item’ elements. These additional boxes are placed with respect to the principal box. Except for table boxes, which are described in a later chapter, and replaced elements, a block-level box is also a block container box. A block container box either contains only block-level boxes or establishes an inline formatting context and thus contains only inline-level boxes. Not all block container boxes are block-level boxes: non-replaced inline blocks and non-replaced table cells are block containers but not block-level boxes. Block-level boxes that are also block containers are called block boxes. The three terms “block-level box,” “block container box,” and “block box” are sometimes abbreviated as “block” where unambiguous. what is line box In an inline formatting context, boxes are laid out horizontally, one after the other, beginning at the top of a containing block. Horizontal margins, borders, and padding are respected between these boxes. The boxes may be aligned vertically in different ways: their bottoms or tops may be aligned, or the baselines of text within them may be aligned. The rectangular area that contains the boxes that form a line is called a line box. 行盒子（line box） 的高度的计算 计算line box中的每一个inline-level box；对于可替换元素（replaced elements），inline-block 和 inline-table元素， 行盒子的高度就是这些元素的外边距盒子（margin box）的高度；对于 内联盒子（inline boxes， that applied ‘display: inline’）,它们的line-height就是行盒子的高度 内联级别的盒子（inline-level box）通过属性vertical-align进行垂直方向的对齐。盒子要按照vertical-align属性进行对齐，并且要在对齐的基础上使行盒子高度最小。 行盒子的高度是最上面盒子的top 到 最下面盒子的bottom之间的距离空的内联元素生成空的内联盒子，但是这些盒子任然有margins, padding, borders 和 line-height, 所以他们一样参与行盒子的高度的计算 Leading and half-leading对于每一个字形，需要添加前导L， L = ‘line-height’- AD, half-leading 添加到A的上面，另一半添加到D的下面。所以每个字形的baseline的上面的总高度是 A+L/2, baseline下面的总深度是D+L/2。 所以当 line-height == height的时候，此时当元素的baseline 和子元素的baseline对齐，子元素就是居中的。 &lt;div class="block" &gt; &lt;span style="border: 1px solid #000;"&gt;hello&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .block &#123; display: block; width: 500px; height: 50px; line-height: 50px; border: 1px solid red; background: linear-gradient(blue, blue) 0 31px/100% 1px no-repeat; &#125;&lt;/style&gt; OUTPUT: line-height介绍ref: https://www.w3.org/TR/CSS21/visudet.html#inline-box-heightline-height = AD + L vertical-align 介绍vertical-align可以应用在inline, inline-block, 和 table-cell元素上，不能应用在block元素上 vertical-align 语法 /* Keyword values *//**** 对于没有baseline的元素，使用元素的bottom margin edge 代替baseline**//* * baseline: 元素行盒的baseline和父元素盒子的baseline对齐（像&lt;textarea&gt;这种baseline没有统一标准，在不同的浏览器中可能表现不同） */vertical-align: baseline; /* default value *//** sub: 元素行盒的baseline和父元素盒子的下标基线对齐*/vertical-align: sub;/** super: 元素行盒的baseline和父元素盒子的上标基线对齐*/vertical-align: super;/** text-top: 元素行盒的top和 父元素**字体**的top对齐*/vertical-align: text-top;/** text-bottom: 元素行盒的bottom和 父元素**字体**的bottom对齐*/vertical-align: text-bottom;/** middle: 元素行盒的middle和父元素的 baseline + (x-height / 2) 对齐*/vertical-align: middle;/** IMPORTANT: top, bottom 是元素相对于行盒的对齐位置；上面的是行盒相对于父盒子的对齐位置*//** top: 将元素的顶部，以及它的后代于行盒的顶部（top）对齐*/vertical-align: top;/** bottom: 将元素的底部，以及它的后代于行盒的底部（bottom）对齐*/vertical-align: bottom;/* &lt;length&gt; values *//** 元素行盒的baseline和父元素盒子的 baseline 以上&lt;length&gt;个像素对齐*/vertical-align: 10em;vertical-align: 10px;/* &lt;percentage&gt; values *//** 元素行盒的baseline和父元素盒子的 baseline 以上(&lt;percentage&gt; * line-height )个像素对齐*/vertical-align: 10%;/* Global values */vertical-align: inherit;vertical-align: initial;vertical-align: unset; vertical-align 的 baseline对齐的例子&lt;div class="block"&gt; &lt;input type="text" class="inline-block-input" value="text"&gt; &lt;span class="inline-block-text"&gt;*bc&lt;/span&gt; &lt;input type="text" class="inline-block-input" value="text"&gt;&lt;/div&gt;&lt;style&gt; .block &#123; display: block; width: 500px; height: 50px; border: 1px solid red; background: linear-gradient(blue, blue) 0 31px/100% 1px no-repeat;&#125;.inline-block-input &#123; display: inline-block; width: 100px; height: 30px; line-height: 30px; background: transparent; border:1px solid;&#125;.inline-block-text &#123; display: inline-block; width: 50px; text-align: center; height: 30px; line-height: 50px; border:1px solid green;&#125;&lt;/style&gt; 例子结果展示： (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vertical-align</tag>
        <tag>line-height</tag>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP缓存（转载自developer.google.com）]]></title>
    <url>%2F2019%2F11%2F28%2F743319a28402c588d40d5708a261f586%2F</url>
    <content type="text"><![CDATA[通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。好在每个浏览器都自带了 HTTP 缓存实现功能。您只需要确保每个服务器响应都提供正确的 HTTP 标头指令，以指示浏览器何时可以缓存响应以及可以缓存多久。注：如果您在应用中使用 Webview 来获取和显示网页内容，可能需要提供额外的配置标志，以确保 HTTP 缓存得到启用、其大小根据用例进行了合理设置并且缓存将持久保存。务必查看平台文档并确认您的设置！当服务器返回响应时，还会发出一组 HTTP 标头，用于描述响应的内容类型、长度、缓存指令、验证令牌等。例如，在上图的交互中，服务器返回一个 1024 字节的响应，指示客户端将其缓存最多 120 秒，并提供一个验证令牌（“x234dff”），可在响应过期后用来检查资源是否被修改。 通过 ETag 验证缓存的响应TL;DR 服务器使用 ETag HTTP 标头传递验证令牌。 验证令牌可实现高效的资源更新检查：资源未发生变化时不会传送任何数据。 假定在首次获取资源 120 秒后，浏览器又对该资源发起了新的请求。首先，浏览器会检查本地缓存并找到之前的响应。遗憾的是，该响应现已过期，浏览器无法使用。此时，浏览器可以直接发出新的请求并获取新的完整响应。不过，这样做效率较低，因为如果资源未发生变化，那么下载与缓存中已有的完全相同的信息就毫无道理可言！这正是验证令牌（在 ETag 标头中指定）旨在解决的问题。服务器生成并返回的随机令牌通常是文件内容的哈希值或某个其他指纹。客户端不需要了解指纹是如何生成的，只需在下一次请求时将其发送至服务器。如果指纹仍然相同，则表示资源未发生变化，您就可以跳过下载。在上例中，客户端自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。服务器根据当前资源核对令牌。如果它未发生变化，服务器将返回“304 Not Modified”响应，告知浏览器缓存中的响应未发生变化，可以再延用 120 秒。请注意，您不必再次下载响应，这节约了时间和带宽。作为网络开发者，您如何利用高效的重新验证？浏览器会替我们完成所有工作：它会自动检测之前是否指定了验证令牌，它会将验证令牌追加到发出的请求上，并且它会根据从服务器接收的响应在必要时更新缓存时间戳。我们唯一要做的就是确保服务器提供必要的 ETag 令牌。检查您的服务器文档中有无必要的配置标志。注：提示：HTML5 Boilerplate 项目包含所有最流行服务器的配置文件样例，其中为每个配置标志和设置都提供了详细的注解。在列表中找到您喜爱的服务器，查找合适的设置，然后复制/确认您的服务器配置了推荐的设置。 Cache-ControlTL;DR 每个资源都可通过 Cache-Control HTTP 标头定义其缓存策略 Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久。 从性能优化的角度来说，最佳请求是无需与服务器通信的请求：您可以通过响应的本地副本消除所有网络延迟，以及避免数据传送的流量费用。为实现此目的，HTTP 规范允许服务器返回 Cache-Control 指令，这些指令控制浏览器和其他中间缓存如何缓存各个响应以及缓存多久。注：Cache-Control 标头是在 HTTP/1.1 规范中定义的，取代了之前用来定义响应缓存策略的标头（例如 Expires）。所有现代浏览器都支持 Cache-Control，因此，使用它就够了。 “no-cache”和“no-store”“no-cache”表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。相比之下，“no-store”则要简单得多。它直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。 “public”与“private”如果响应被标记为“public”，则即使它有关联的 HTTP 身份验证，甚至响应状态代码通常无法缓存，也可以缓存响应。大多数情况下，“public”不是必需的，因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。相比之下，浏览器可以缓存“private”响应。不过，这些响应通常只为单个用户缓存，因此不允许任何中间缓存对其进行缓存。例如，用户的浏览器可以缓存包含用户私人信息的 HTML 网页，但 CDN 却不能缓存。 “max-age”指令指定从请求的时间开始，允许获取的响应被重用的最长时间（单位：秒）。例如，“max-age=60”表示可在接下来的 60 秒缓存和重用响应。 定义最佳 Cache-Control 策略按照以上决策树为您的应用使用的特定资源或一组资源确定最佳缓存策略。在理想的情况下，您的目标应该是在客户端上缓存尽可能多的响应，缓存尽可能长的时间，并且为每个响应提供验证令牌，以实现高效的重新验证。 Cache-Control 指令和说明 max-age=86400 浏览器以及任何中间缓存均可将响应（如果是“public”响应）缓存长达 1 天（60 秒 x 60 分钟 x 24 小时）。 private, max-age=600 客户端的浏览器只能将响应缓存最长 10 分钟（60 秒 x 10 分钟）。 no-store 不允许缓存响应，每次请求都必须完整获取。 根据 HTTP Archive，在排名最高的 300,000 个网站（按照 Alexa 排名）中，所有下载的响应中几乎有半数可由浏览器缓存，这可以大量减少重复的网页浏览和访问。当然，这并不意味着您的特定应用有 50% 的资源可以缓存。一些网站的资源 90% 以上都可以缓存，而其他网站可能有许多私密或时效要求高的数据根本无法缓存。请审核您的网页，确定哪些资源可以缓存，并确保它们返回正确的 Cache-Control 和 ETag 标头。 废弃和更新缓存的响应TL;DR 在资源“过期”之前，将一直使用本地缓存的响应。 您可以通过在网址中嵌入文件内容指纹，强制客户端更新到新版本的响应。 为获得最佳性能，每个应用都需要定义自己的缓存层次结构。 浏览器发出的所有 HTTP 请求会首先路由到浏览器缓存，以确认是否缓存了可用于满足请求的有效响应。如果有匹配的响应，则从缓存中读取响应，这样就避免了网络延迟和传送产生的流量费用。不过，如果您想更新或废弃缓存的响应，该怎么办？例如，假定您已告诉访问者将某个 CSS 样式表缓存长达 24 小时 (max-age=86400)，但设计人员刚刚提交了一个您希望所有用户都能使用的更新。您该如何通知拥有现在“已过时”的 CSS 缓存副本的所有访问者更新其缓存？在不更改资源网址的情况下，您做不到。浏览器缓存响应后，缓存的版本将一直使用到过期（由 max-age 或 expires 决定），或一直使用到由于某种其他原因从缓存中删除，例如用户清除了浏览器缓存。因此，构建网页时，不同的用户可能最终使用的是文件的不同版本；刚获取了资源的用户将使用新版本的响应，而缓存了早期（但仍有效）副本的用户将使用旧版本的响应。所以，如何才能鱼和熊掌兼得：客户端缓存和快速更新？您可以在资源内容发生变化时更改它的网址，强制用户下载新响应。通常情况下，可以通过在文件名中嵌入文件的指纹或版本号来实现 - 例如 style.x234dff.css。因为能够定义每个资源的缓存策略，所以您可以定义“缓存层次结构”，这样不但可以控制每个响应的缓存时间，还可以控制访问者看到新版本的速度。为了进行说明，我们一起分析一下上面的示例： HTML 被标记为“no-cache”，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时获取最新版本。此外，在 HTML 标记内，您在 CSS 和 JavaScript 资产的网址中嵌入指纹：如果这些文件的内容发生变化，网页的 HTML 也会随之改变，并会下载 HTML 响应的新副本。 允许浏览器和中间缓存（例如 CDN）缓存 CSS，并将 CSS 设置为 1 年后到期。请注意，您可以放心地使用 1 年的“远期过期”，因为您在文件名中嵌入了文件的指纹：CSS 更新时网址也会随之变化。 JavaScript 同样设置为 1 年后到期，但标记为 private，这或许是因为它包含的某些用户私人数据是 CDN 不应缓存的。 图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。 您可以组合使用 ETag、Cache-Control 和唯一网址来实现一举多得：较长的过期时间、控制可以缓存响应的位置以及随需更新。 缓存检查清单不存在什么最佳缓存策略。您需要根据通信模式、提供的数据类型以及应用特定的数据更新要求，为每个资源定义和配置合适的设置，以及整体的“缓存层次结构”。在制定缓存策略时，您需要牢记下面这些技巧和方法： 使用一致的网址：如果您在不同的网址上提供相同的内容，将会多次获取和存储这些内容。提示：请注意，网址区分大小写。 确保服务器提供验证令牌 (ETag)：有了验证令牌，当服务器上的资源未发生变化时，就不需要传送相同的字节。 确定中间缓存可以缓存哪些资源：对所有用户的响应完全相同的资源非常适合由 CDN 以及其他中间缓存进行缓存。 为每个资源确定最佳缓存周期：不同的资源可能有不同的更新要求。为每个资源审核并确定合适的 max-age。 确定最适合您的网站的缓存层次结构：您可以通过为 HTML 文档组合使用包含内容指纹的资源网址和短时间或 no-cache 周期，来控制客户端获取更新的速度。 最大限度减少搅动：某些资源的更新比其他资源频繁。如果资源的特定部分（例如 JavaScript 函数或 CSS 样式集）会经常更新，可以考虑将其代码作为单独的文件提供。这样一来，每次获取更新时，其余内容（例如变化不是很频繁的内容库代码）可以从缓存获取，从而最大限度减少下载的内容大小。(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;; } else { bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s);})();&lt;/script&gt;]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤（Bloom Filter）]]></title>
    <url>%2F2019%2F11%2F18%2Fbbc765cf2f120d4208792bc259324906%2F</url>
    <content type="text"><![CDATA[Bloom Filter1. 什么是布隆过滤？布隆过滤是应用于大数据中检测一个数据是否在一个集合中的搜索过滤算法。2. 应用场景比如如何在成千上万的网址中快速地识别出恶意的网址，在成千上万的邮件中快速识别出恶意的邮件等3. 算法简单描述布隆过滤是在一个bitmap中预先通过k个hash函数插入一些目标数据标记，表示为下图：假设这里的bitmap(所有的位都初始化为0)是有10个bits，有3个hash 函数，有一个目标数据“cat”，那么将cat映射标记到bitmap就是通过3个hash函数分别计算cat的hash值，将hash值转换成bitmap的索引，并将对应索引位置的bit置为1，至此，我们就标记了一个目标数据，目前cat就是我们要过滤的数据，当在很多的数据中要识别出“cat”的时候，就可以通过建立好的这个bitmap来识别了。 比如，现在有3个数据来了，分别是 “dog”，“cat”，“pig”，我们需要从中识别出“cat”，怎么样识别呢？“dog” =&gt; 映射到 bitmap[1], bitmap[2], bitmap[3], 发现都不是1，则‘dog‘就不是目标数据“cat” =&gt; 映射到 bitmap[1], bitmap[3], bitmap[7],发现所有的都是1， 则 ‘cat’就是目标数据“pig” =&gt; 映射到 bitmap[8], bitmap[9], bitmap[10]，发现都不是1， 则‘pig’就不是目标数据这样通过重新计算hash来和bitmap中的对比就能过滤掉一些目标数据了但是这里其实还有一个问题，存在一个不同的目标,比如“bird”，这个通过hash函数计算出来的结果可能在bitmap中都为1, 这种情况是无法避免的，我们称之为“误判”，这种识别错误的概率和目标数据，bitmap大小和hash函数的数据是相关联的 4. 算法推导布隆过滤的原理大概了解了，但是这里有个问题是，如何确定bitmap的大小以及hash function的多少，我们可以通过指定一个错误概率的大小和初始的目标数据来确定 bitmap的大小和hash function 的数量 假设有 K个hash函数，M bits的bitmap， N个初始数据, 对于bitmap中的一个特定点，K个hash函数映射到此点的·概率相等，即一个点被函数命中的概率为： p_1=\frac{1}{M}则一个点不被命中的概率为： p_2=1-\frac{1}{M}则K个函数都不命中的概率为： p_3=\left(1-\frac{1}{M}\right)^K假设已经存在了N个数据，那么一个特定的点在N个数据下都没有被命中的概率为： p_4=\left(1-\frac{1}{M}\right)^{KN}那么这个点命中的概率为： p_5=1-\left(1-\frac{1}{M}\right)^{KN}现在来判断一个不再初始数据集合中的数据被命中的概率，即，满足K个hash函数计算的结果都被命中，这种情况的概率为： p_6=\left(1-\left(1-\frac{1}{M}\right)^{KN}\right)^K因为目标数据命中的概率为1，所以当p_6越小的时候，也就表示别的数据被命中的概率越低。根据 1-\frac{1}{m}\approx\ell^{-\frac{1}{m}}可以将p_6简化为：\ell^{-\frac{KN}{M}} p_6\approx\left(1-\ell^{-\frac{KN}{M}}\right)^K因为K为正数，取其值为\frac{M}{N}\ln2， 则 p_6\approx\left(1-\ell^{-\frac{\left(\frac{M}{N}\ln2\right)N}{M}}\right)^{\frac{M}{N}\ln2}\ln{p_6}\approx{\frac{M}{N}\ln2}\times\ln\left(1-\ell^{-\frac{\left(\frac{M}{N}\ln2\right)N}{M}}\right)\ln{p_6}\approx{\frac{M}{N}\ln2}\times\ln\left(1-\ell^{-\ln2}\right)\ln{p_6}\approx{\frac{M}{N}\ln2}\times\ln\left(1-\frac{1}{\ell^{\ln2}}\right)\ln{p_6}\approx\frac{M}{N}\ln2\times\ln\frac{1}{2}\ln{p_6}\approx\frac{M}{N}\ln2\times{\left(-\ln2\right)}\ln{p_6}\approx{-\frac{M}{N}{\left(\ln2\right)}^2}所以最终 M = -\frac{\ln{p_6} \times N}{ \left(\ln2\right)^2 }所以当我们希望误判命中的概率是 0.001, 初始化插入了 10000 条数据， 那么M 就等于 Math.log(0.001)*10000 / Math.pow(Math.log(2), 2) * -1 // output: 143775.87566051158 那么 K就等于 143776 / 10000 * Math.log(2) // output: 9.965... 也就是需要10个hash函数 5. 代码实现https://github.com/zhangyunfeng/BloomFilter/tree/master/src (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>bloom filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见WEB安全防御]]></title>
    <url>%2F2019%2F11%2F18%2Ff97ef80c3fff95b1c02a4a937d666b66%2F</url>
    <content type="text"><![CDATA[WEB安全[TOC]一、漏洞分类 XSS漏洞 CSRF漏洞 SSRF漏洞 SQL漏洞 二、各种漏洞介绍XSS漏洞 什么是XSS漏洞XSS漏洞全称跨站脚本攻击，英文全称 Cross-site Scripting, 为了不和css名字重复，所以取名XSS. XSS漏洞主要是能够利用代码的漏洞，通过一些技巧在浏览器端执行非法的javascript脚本，这些非法的javascript脚本拥有当前登录用户的权限，可以执行一些非法操作，从而给用户或者企业带来损失。 XSS漏洞的种类 DOM型XSS 这个是最常见的一个XSS漏洞了，在在浏览器端操作DOM时产生。比如，在一个input中输入一个字符串，并将字符串显示在页面中，如果没有对字符串做校验就可能会产生DOM型xss漏洞。例子： https://pastebin.com/C1inFY9n https://pastebin.com/C1inFY9n 反射型XSS 反射型XSS是发送到服务端的数据没有做参数的校验和过滤，只是简单地把用户输入的数据”反射”给浏览器,导致在浏览器中渲染处理参数时引入了js脚本。反射型XSS也叫做”非持久型XSS” (Non-persistent XSS) 存储型XSS . 存储型XSS会把用户输入的数据”存储”在服务端, 这种XSS具有很强的稳定性.最常见的一种情况就是,在博客中写一段包含有恶意javascript代码发表, 这段恶意的代码就会随着博客内容存储到数据库中,如何人访问这篇博客都会受到攻击 XSS漏洞的危害a. 窃取cookie,登录别人账户攻击者可以构造一个链接,当被攻击者点击了这个链接之后,会触发xss漏洞,就会执行一个js脚本,该js脚本会携带cookie信息通过img标签或者script标签等可以跨域访问的标签将信息发送给攻击者.b. 构造GET和POST请求,删除或者篡改受害者信息比如有个删除文章的接口: http://blog.abc.com/delete?id=post_idxxx, 当攻击者知道被攻击者的一篇文章的id的时候,就可以通过xss payload来请求删除文章的接口, 修改被攻击者信息同理.c. XSS钓鱼xss的攻击过程都是需要在浏览器中通过javascript自动执行的.如果在攻击的过程中存在和用户交互的情况就比较麻烦了,比如需要输入旧密码或者输入图片上的验证码,虽然比较麻烦,但是我们还是可以实施xss攻击的,比如把显示验证码的图片地址发送给攻击者,或者制作一个长得一模一样的输入帐号密码的界面欺骗被攻击者.这些攻击方法就是xss钓鱼.d. 识别用户的浏览器,利用浏览器的漏洞对系统进行攻击浏览器有漏洞,虽然浏览器会通过更新来解决这些漏洞,但是不能保证所有的人都更新到最新版本,当检测到有漏洞的浏览器版本,就可以通过浏览器漏洞对系统进行攻击.e. 识别用户安装的软件执行挂马攻击在IE中可以通过判断 ActieX空间的classid是否存在来判断用户是否安装了软件.黑客通过判断被攻击者安装的软件,选择对应的浏览器漏洞,最终达到植入木马的目的.比如在IE中通过如下的代码就可以判断用户是否安装了迅雷:try &#123; var obj = new ActiveXObject('XunLeiBHO.ThunderIEHelper');&#125; catch (error) &#123; // 异常, 没有安装此软件&#125;if (obj) &#123; // 安装了迅雷&#125; 另外,可以通过flash的一个 system.capabilities对象来找出电脑的硬件信息,还可以通过判断特定的DOM来判断浏览器安装了哪些插件. 通过xss攻击还可以知道被攻击者访问了哪些页面(通过 :visited 伪元素判断), 还可以在jre环境中通过调用Java Applete的接口获取客户端的本地ip地址. XSS的防御a. HttpOnly通过在cookie中设置HttpOnly这个属性,可以阻止javascript访问cookie内容.b. 输入检查对输入的值进行字符类型,字符长度检查,比如手机号码,不能出现字母,而且长度为11, 对一些特殊字符,比如尖括号进行转义编码,或者一些特殊的字符串进行过滤,比如 &lt;script&gt;, javascript:.c. 输出检查执行安全的编码函数, htmlEncode, javascriptEncode.在html中输出变量$var,使用 htmlEncode对$var进行编码.在html中的onclick等事件中输出,使用javascript对$var编码在javascript中输出$var, 使用 javascript对$var编码在css中,禁止变量输出,即不要在style中使用$var变量在地址中输出,使用urlEncoded. 处理富文本通过htmlparser解析文本,过滤掉危险标签 &lt;iframe&gt;, &lt;script&gt;, &lt;base&gt;, &lt;form&gt;等, 在富文本中可选择的标签使用白名单,避免使用黑名单,即指定富文本中只能使用哪几种标签.e.编写代码时,注意这些地方;document.write();document.writeln();xxx.innerHTML();xxx.outerHTML();innerHTML.replace();document.attachEvent();window.attachEvent();document.location.replace();document.location.assign();// 页面中所有的input输入框window.location(href, hash, ...)window.namedocument.referrerdocument.cookielocalstorageXMLHttpRequest // 主要是返回的数据 CSRF漏洞CSRF漏洞,全称Cross Site Request Forgery/ˈfɔːdʒəri/ 伪造, 比如存在一个转账的接口:http://bank.com/transform/?money=xxx&amp;to=zzz; 攻击者可以伪造一个链接 http://bank.com/transform/?money=1&amp;o=lisi, 诱惑用户点击这个链接,那么用户在神不知鬼不觉之下就转移了1元钱给李四, 这个伪造的链接可以放到一个网页的img标签中, 当用户点击这个网页的时候,钱就被神不知鬼不觉的转走了. 为什么伪造的请求会请求通过呢?因为用户的浏览器成功的发送了Cookie给服务器. 防御方法: 增加一个随机的token, 每次转账的时候都要带上这个随机额token, 同事后台需要校验token的正确性,比如 http://bank.com/transform/?money=xxx&amp;to=zzz&amp;token=abcUx23Flzd, 这样攻击者不知道token的情况下,构造的链接就会无效. 点击劫持(ClickJacking)点击劫持是一种视觉上的欺骗手段.攻击者使用一个透明的iframe,覆盖在一个网页上,然后诱使用户在网页上进行操作,通过调整iframe的位置,当用户点击一个按钮的时候,其实是点击在iframe上的一个功能按钮上. 点击劫持有: Flash点击劫持 图片覆盖攻击 拖拽劫持与数据窃取 触屏劫持 防御:禁止跨域的iframe来防御, 使用HTTP头 X-Frame-Options, X-Frame-Options有3个选项, DENY, SAMEORIGIN, ALLOW-FROM origin (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索算法]]></title>
    <url>%2F2019%2F11%2F18%2Fb7d273159f6becc31fc5174ea7582c5e%2F</url>
    <content type="text"><![CDATA[线性搜索线性搜索也是最简单的搜索算法，简单来说，就是对一个数组或者顺序容器，进行从头到尾的遍历，一个一个的找到目标元素// 简单的线性搜索算法实现template &lt;typename T&gt;int linear_search(const std::vector&lt;T&gt;&amp; vec, const T&amp; x)&#123; int index = -1; for(const auto&amp; element : vec) &#123; index++; if(element == x) &#123; return index; &#125; &#125; return -1;&#125; 时间复杂度： O(N) 二分查找（Binary Search）二分查找，是给定一个有序的数组或者顺序容器，每次取容器的中间位置的元素和目标元素对比来缩短查找的范围。过程可以简单描述如下：// 二分查找template&lt;typename T&gt;extern int binary_search(const std::vector&lt;T&gt;&amp; vec, const int low, const int high, const T&amp; x) &#123; std::cout &lt;&lt; "binary_search low " &lt;&lt; low &lt;&lt; " high " &lt;&lt; high &lt;&lt; std::endl; if (low &gt; high) &#123; // 没有找到 return -1; &#125; int middle = low + (high - low) / 2; // 搜索区间缩短一半 if (x == vec.at(middle)) &#123; return middle; &#125; int low_ = vec.at(middle) &gt; x ? low : middle + 1; int high_ = vec.at(middle) &gt; x ? middle - 1 : high; return binary_search(vec, low_, high_, x);&#125; 时间复杂度： O(LogN) 跳跃查找（Jump Search）给定一个有序的顺序容器，容器宗有n个元素， 将元素分成m份，每份 n/m 个元素。然后我们按照每n/m个元素间隔去查找元素，找到要搜索的元素所在的区间[i, i+n/m), 然后在这个区间中判断值 template&lt;typename T&gt;extern int jump_search(const std::vector&lt;T&gt;&amp; vec, const T&amp; x) &#123; if (vec.size() == 0) &#123; return -1; &#125; int stepWidth = std::sqrt(vec.size()); int prevStepIndex = 0; int stepIndex = std::min(stepWidth, int(vec.size())) - 1; while (vec.at(stepIndex) &lt; x) &#123; prevStepIndex = stepIndex; stepIndex = std::min(stepWidth + stepIndex, int(vec.size() - 1)); if (prevStepIndex == stepIndex) &#123; // 到达尾部，没有找到x元素 return -1; &#125; &#125; // ignore all elements less than x while (vec.at(prevStepIndex) &lt; x) &#123; prevStepIndex++; if (prevStepIndex &gt;= vec.size()) &#123; return -1; &#125; &#125; // if element found if (vec.at(prevStepIndex) == x) &#123; return prevStepIndex; &#125; return -1;&#125; 算法分析寻找要查找的元素所在的区间，最大需要为 m - 1次比较，再区间段中最大需要n/m次比较 ，所以时间复杂度是 O((m-1) + n/m),要使 (m-1) + n/m 最小，需要 m = sqrt(n),所有， 时间复杂度是 O(sqrt(n) - 1 + n/sqrt(n)) 也就是 O(sqrt(n)) 让 n/m+m-1 = 0, jump search 的时间复杂度，是介于线性查找和二分查找之间的，所以jump search 的性能没有比二分查找要好，但是jump search 有一个好处，就是他只需要回退一次，加入我们要查找一个最小的元素，jump search 只需要查找一个，而二分查找需要查满，这种情况下，jump search 是优于 二分查找的。 差值搜索 （Interpolation Search）差值搜索是对二分搜索的优化，二分搜索永远都是从搜索区间的中间位置开始切分，而差值搜索会从选择从要搜索的元素最接近的位置开始切分，这样就有利于尽快的找到要搜索的元素 template&lt;typename T&gt;inline int position(const std::vector&lt;T&gt;&amp; vec, const T&amp; x, int low, int high) &#123; return low + (high - low) * ((x - vec.at(low)) / (vec.at(high) - vec.at(low)));&#125;template &lt;typename T&gt;int interpolation_search(const std::vector&lt;T&gt;&amp; vec, const T&amp; x) &#123; int low = 0; int high = vec.size() - 1; while (low &lt;= high &amp;&amp; x &gt;= vec.at(low) &amp;&amp; x &lt;= vec.at(high)) &#123; int pos = position(vec, x, low, high); printf("position is %d \n", pos); if (vec.at(pos) == x) &#123; return pos; &#125; if (vec.at(pos) &lt; x) &#123; low = pos + 1; continue; &#125; high = pos - 1; &#125; return -1;&#125; 算法分析：如果顺序容器中的元素是均匀分布的，那么就是时间复杂度就是 O(log log n)), 最坏的情况是 O(n) (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome调试微信web页面]]></title>
    <url>%2F2019%2F11%2F17%2F302d853864089ff3288321c00a69a043%2F</url>
    <content type="text"><![CDATA[如何用Chrome调试微信web页面 微信调试有官方的微信开发者工具，这个工具很方便，但是有一个不方便就是调试公众号页面的时候，需要公众号给你授予开发者权限，但是有的时候，你仅仅只是想调试页面的样式和一些dom结构，这个时候直接用chrome调试微信web页面就显得特别方便了。 步骤（此处仅仅在android手机上做了测试）1. 打开android手机的开发者模式 和 usb调试 每个手机打开方式都不一样，请自行搜索解决方案 2. 打开chrome的 Remote Devices 3. 手机连接电脑 手机连接电脑的时候，会弹出一个usb授权提示弹窗，点解确定 4. 在Chrome上的 Remote Devices上查看链接的手机情况 5. 调试手机上的页面 点击要调试的页面的右边的 Inspect按钮，就可以打开进行调试了。 但是这个时候我们发现仅仅只能看到浏览器的页面，没有看到微信的web页面 6. 手机微信打开 http://debugx5.qq.com, 并勾选 打开TBS内核Inspector调试功能 勾选后会提示重启，点击确定就行 7. 微信上打开要调试的web 页面，就可以在chrome中看到了 8. 点击chrome中 inspect按钮及可以开始调试了 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>debugger</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决JPEG图片显示方向不正确的问题]]></title>
    <url>%2F2019%2F11%2F17%2Fd3c4828a43569ce3ca593dc66b1eb668%2F</url>
    <content type="text"><![CDATA[背景： 一些jpeg图片，在pc中用图片查看器打开是正的，但是放到浏览器中，就横着了；有一个上传人脸的需求，用手机拍完人脸照片，在应用中显示所拍的照片总是横着的。今天，我们就来解决这个问题。为什么JEPG图片会横着显示？首先，我们看一个github上的一个关于此问题的issue：https://github.com/GoogleChromeLabs/squoosh/issues/299这个问题讨论的是chrome显示jpeg图片，旋转了90度的问题。为什么会旋转呢？因为JEPG图片的EXIF data中有一个控制旋转的属性Orientation，但是有一些应用程序显示图片的时候会忽略这个属性，就导致图片在一些应用程序中显示出来和原本的方向不一致。 这里有一张JEPG图片的EXIF数据（可以看到第一个属性就是 Orientation）： 让图片永远都正着显示因为 JPEG的 Orientation 属性被忽略了，那么当检测到图片Orientation的值表示需要旋转的时候，我们就主动将JPEEG图片旋转，并且改正或者去掉新图片的Orientation 字段。 // 使用exif-js 这个库去获取jpeg图片的EXIF元数据 (https://github.com/exif-js/exif-js)// 旋转图片的工具,(旋转之后的图片的EXIF data被移除) import * as EXIF from 'exif-js' // npm install exif-js // &lt;img id="show-image" /&gt;,用来显示旋转后的图像 var image = document.getElementById('show-image') // &lt;input id="image-input" type="file" name="imag" /&gt; var imageInput = document.getElementById('image-input') imageInput.onchange = function (evt) &#123; console.log("onchange: ...") let file = evt.target.files[0] rotateImage(file).then(data =&gt; &#123; image.src = data.base64 &#125;) &#125; function fileToBinary (file) &#123; // 读取图片数据 return new Promise(function (resolve, reject) &#123; var reader = new FileReader() reader.onload = function(evt) &#123; if (this.result instanceof ArrayBuffer) &#123; // resolve(new Uint8Array(reader.result)) resolve(this.result) &#125; &#125; reader.readAsArrayBuffer(file) &#125;) &#125; // 将Blob 对象以fileName文件名下载下来 function downloadBlob (blob, fileName) &#123; const url = window.URL.createObjectURL(blob) const link = document.createElement('a') link.href = url link.setAttribute('download', fileName) document.body.appendChild(link) link.click() document.body.removeChild(link) // 下载完成移除元素 window.URL.revokeObjectURL(url) // 释放掉blob对象 &#125; function rotateImage(file)&#123; return new Promise((resolve, reject) =&gt; &#123; fileToBinary(file).then((binaryFile) =&gt; &#123; let meta = EXIF.readFromBinaryFile(binaryFile) let orientation = meta.Orientation let formData = new FormData() let rotationMap = &#123; 3: 180, 6: 90, 8: 270 &#125; // 不需要旋转 if (meta === false || !rotationMap[orientation]) &#123; formData.append('file', file, 'face.jpeg') return resolve(&#123; base64: '', formData: formData, rotated: false &#125;) &#125; let rotationDegree = 0 let targetWidth = 200 rotationDegree = rotationMap[orientation] || 0 let image = document.createElement('img') image.onload = function () &#123; var canvas = document.createElement('canvas') let ctx = canvas.getContext('2d') let rate = Math.min(targetWidth / image.width, 1) let imageWidth = image.width * rate let imageHeight = image.height * rate if (rotationDegree === 90 || rotationDegree === 270) &#123; canvas.width = imageHeight canvas.height = imageWidth &#125; else &#123; canvas.width = image.width canvas.height = image.height &#125; ctx.fillStyle = 'rgba(255, 255, 255, 0)' ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.save() ctx.fillRect(0, 0, canvas.width, canvas.height) ctx.translate(canvas.width / 2, canvas.height / 2) ctx.rotate(rotationDegree * Math.PI / 180) if (rotationDegree === 90 || rotationDegree === 270) &#123; ctx.drawImage(image, -canvas.height / 2, -canvas.width / 2 + (canvas.width - imageHeight) / 2, imageWidth, imageHeight) &#125; else &#123; ctx.drawImage(image, -canvas.width / 2, -canvas.height / 2, imageWidth, imageHeight) &#125; ctx.restore() canvas.toBlob((blob) =&gt; &#123; formData.append('file', blob, 'face.jpeg') let base64 = canvas.toDataURL('image/jpeg', 0.8) console.log('rotated image blob: ', blob) // downloadBlob(blob, '123.jpg') // 下载图片 resolve(&#123; base64: base64, rotated: true, formData: formData &#125;) &#125;, 'image/jpeg', 0.8) &#125; image.src = URL.createObjectURL(file) &#125;) &#125;) &#125; 例子效果： (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jpg</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用操作]]></title>
    <url>%2F2019%2F11%2F13%2Fa43fd1c509d10e4d08fc1f789d58cb23%2F</url>
    <content type="text"><![CDATA[漂亮打印git loggit log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative添加修改或者新文件到待commit队列### add 的文件是支持正则匹配的git add &lt;file(s)&gt;### add all changes to commiter queuegit add .### 查看某个commit的修改内容git show &lt;commit-id&gt;git diff &lt;commit-id&gt;^!##### e.g. git show d34ff657f5 git diff d34ff657f5^!``` ### 提交已添加的文件到本地仓库并创建一个新的版本```shgit commit -m "commit message"### also can combine git add &amp; git commit in one commandgit commit -m "commit message" -a 推送到远程仓库### origin 是仓库名（默认就是origin），branch_name 是分支名git push origin &lt;branch-name&gt; 仓库创建一个仓库### from existed repo git clone &lt;repo-url&gt;### create a new local repogit init [&lt;local-directory&gt;] 分支查看分支### 查看本地分支git branch### 查看本地和远端的分支git branch -va### 查看本地分支和远程分支的对应关系git remote show &lt;repo-name&gt; ## git remote show origin 创建分支### 仅仅创建一个新分支在本地git checkout &lt;new-branch-name&gt;### 创建一个分支，并且将工作区切换到新创建的分支git checkout -b &lt;new-branch-name&gt;### 拉取远程分支到本地，并切换分支git checkout -b &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt;#### e.g.: git checkout -b test origin/test### 把远程分支拉取到本地，不切换分支 (--tranck 选项现在是默认的了)git branch &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt; [--track]#### e.g.: git branch test origin/test 将本地分支推送到远程仓库## 远程分支不存在的情况### remote-name: 通常是 origin； local-branch-name: 本地分支名； remote-branch-name: 要创建的远程分支名 git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt; ## 远程分支存在的情况（但是没有关联） ### 首先关联本地分支和远程分支 git push -u &lt;remote-name&gt; &lt;branch-name&gt; #### or git branch --set-upstream-to=&lt;remote-name&gt;/&lt;remote-branch&gt; &lt;local-branch&gt; 更新分支### 跟新本地分支git pull### 更新远程分支信息git remote update### 使用远程的代码强制更新本地的代码 （强制本地代码和线上的一致）v1.0git checkout .git pull### 使用远程的分支代码强制更新本地的代码（强制本地代码和线上的一致）v2.0git fetch --allgit reset --hard origin/mastergit pull Tag创建taggit tag -a &lt;tag-name&gt; -m &lt;tag-message&gt; 删除tag### 删除本地taggit tag -d &lt;tag-name&gt;### 删除远端taggit push --delete &lt;repo-name&gt; &lt;tag-name&gt;or git push &lt;repo-name&gt; :refs/tags/&lt;tag-name&gt;### e.g.: git push --delete origin tag-r0### e.g.: git push origin :refs/tags/tag-r0 查看tag### 查看所有的taggit tag### 查看单个taggit tag -l &lt;tag-name&gt;### 查看一个tag的具体信息git show &lt;tag-name&gt; 推送tag到远程## push single taggit push &lt;remote-name&gt; &lt;tag-name&gt;## push all tags (not recommended)git push --tags 撤销工作目录所有的更改（包括新创建的文件）git reset --hard # removes staged and working directory changes## !! be very careful with these !!## you may end up deleting what you don't want to## read comments and manual.git clean -f -d # remove untrackedgit clean -f -x -d # CAUTION: as above but removes ignored files like config.git clean -fxd :/ # CAUTION: as above, but cleans untracked and ignored files through the entire repo (without :/, the operation affects only the current directory) git仓库存储账号密码，不用每次都输入账号密码（针对https协议的仓库地址）$ git config credential.helper store$ git push https://github.com/owner/repo.gitUsername for 'https://github.com': &lt;USERNAME&gt;Password for 'https://USERNAME@github.com': &lt;PASSWORD&gt;## 执行完上面的命令之后，以后所有的push都不再需要提交代码## 如果想让此功能有个时间限制，可以这样git config --global credential.helper 'cache --timeout 7200'## 7200秒后失效，push需要重新输入账号密码 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
